<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
    <title>LAB</title>
    <style>
        * { box-sizing: border-box;}
        html {
            width: 100%;
            height: 100%;
        }

        body {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        .test-circle {
            width: 288px;
            height: 288px;
            border-radius: 50%;
            background: #c70;
            position: relative;
        }

        .test-circle .piece {
            width: 0;
            height: 92px;
            position: absolute;
            left: 50%;
            bottom: 50%;
            transform-origin: 50% 100%;
        }

        .test-circle .piece:nth-of-type(1) { transform: rotate(0deg);}
        .test-circle .piece:nth-of-type(2) { transform: rotate(45deg);}
        .test-circle .piece:nth-of-type(3) { transform: rotate(90deg);}
        .test-circle .piece:nth-of-type(4) { transform: rotate(135deg);}
        .test-circle .piece:nth-of-type(5) { transform: rotate(180deg);}
        .test-circle .piece:nth-of-type(6) { transform: rotate(225deg);}
        .test-circle .piece:nth-of-type(7) { transform: rotate(270deg);}
        .test-circle .piece:nth-of-type(8) { transform: rotate(315deg);}

        .test-circle .piece .btn {
            width: 56px;
            height: 56px;
            background: rgba(0,0,0,0.4);
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-50%);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding-bottom: 8px;
        }

        .test-circle .piece .btn p {
            margin: 0;
            text-align: center;
            font-size: 11px;
            font-weight: 700;
            line-height: 20px;
        }
    </style>
</head>
<body>
    <div id="pointer" class="test-circle">
        <div class="piece">
            <div class="btn"><p>Button#1</p></div>
        </div>
        <div class="piece">
            <div class="btn"><p>Button#2</p></div>
        </div>
        <div class="piece">
            <div class="btn"><p>Button#3</p></div>
        </div>
        <div class="piece">
            <div class="btn"><p>Button#4</p></div>
        </div>
        <div class="piece">
            <div class="btn"><p>Button#5</p></div>
        </div>
        <div class="piece">
            <div class="btn"><p>Button#6</p></div>
        </div>
        <div class="piece">
            <div class="btn"><p>Button#7</p></div>
        </div>
        <div class="piece">
            <div class="btn"><p>Button#8</p></div>
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            var pointer = document.getElementById("pointer"),
                pointerBox = pointer.getBoundingClientRect(),
                centerPoint = window.getComputedStyle(pointer).transformOrigin,
                centers = centerPoint.split(" ");
            
            var centerY = pointerBox.top + parseInt(centers[1]) - window.pageYOffset,
                centerX = pointerBox.left + parseInt(centers[0]) - window.pageXOffset;

            //var degrees = 0;
            var totalDegrees = 0;
            var startDegrees = 0;
            var lastDegrees = 0;
            var currentDegrees = 0;
            var target = null;
            var dragging = false;
            var startTime = 0;
            var endTime = 0;
            var targetDegrees = 0;
            var lastVelocity = 0;

            requestAnimationFrame(update);

            function calcDegrees(e) {
                var pointerEvent = e;
                if (e.targetTouches && e.targetTouches[0]) {
                    e.preventDefault();
                    pointerEvent = e.targetTouches[0];
                    mouseX = pointerEvent.pageX;
                    mouseY = pointerEvent.pageY;
                } else {
                    mouseX = e.clientX,
                    mouseY = e.clientY;
                }

                var radians = Math.atan2(mouseX - centerX, mouseY - centerY);
                var degrees = (radians * (180 / Math.PI) * -1) + 180;
                return degrees;
            }

            function calcEndDegrees(e) {
                var pointerEvent = e;
                if (e.changedTouches && e.changedTouches[e.changedTouches.length-1]) {
                    e.preventDefault();
                    pointerEvent = e.changedTouches[e.changedTouches.length-1];
                    mouseX = pointerEvent.pageX;
                    mouseY = pointerEvent.pageY;
                } else {
                    mouseX = e.clientX,
                    mouseY = e.clientY;
                }

                var radians = Math.atan2(mouseX - centerX, mouseY - centerY);
                var degrees = (radians * (180 / Math.PI) * -1) + 180;
                return degrees;
            }

            /*function rotatePointer(e) {
                var pointerEvent = e;
                if (e.targetTouches && e.targetTouches[0]) {
                    e.preventDefault();
                    pointerEvent = e.targetTouches[0];
                    mouseX = pointerEvent.pageX;
                    mouseY = pointerEvent.pageY;
                } else {
                    mouseX = e.clientX,
                    mouseY = e.clientY;
                }

                var radians = Math.atan2(mouseX - centerX, mouseY - centerY);
                degrees = (radians * (180 / Math.PI) * -1) + 180;
                pointer.style.transform = 'rotate(' + degrees + 'deg)';

                console.log(degrees);
            }*/



            function onStart(e) {
                
                // if (target)
                //     return;
                dragging = true;

                target = e.currentTarget;
                
                //lastDegrees = startDegrees;
                
                startTime = Date.now() / 1000;

                startDegrees = calcDegrees(e);
                currentDegrees = startDegrees;

                target.style.transition = 'none';
                target.style.willChange = 'transform';

                
                //e.preventDefault();
                //console.log( startDegrees );
            }

            function onMove(e) {
                // if (!target)
                //     return;

                currentDegrees = calcDegrees(e);
                //console.log( currentDegrees - startDegrees );
            }

            function onEnd(e) {
                
                // if (!target)
                //     return;
                targetDegrees = 0;
                endTime = Date.now() / 1000;
                /*let totalDegrees = currentDegrees - startDegrees;
                const threshold = this.targetBCR.width * 0.35;
                if (Math.abs(totalDegrees) > threshold) {
                    targetDegrees = (totalDegrees > 0) ?
                        this.targetBCR.width :
                        -this.targetBCR.width;
                }*/

                dragging = false;

                //lastDegrees = totalDegrees % 360;
                targetDegrees = Math.round( Math.round(totalDegrees % 360) / 45 ) * 45;
                console.log( targetDegrees );
                
                // calculate velocity
                lastVelocity = ( calcEndDegrees(e) - startDegrees) / (endTime - startTime);
            }




            function update() {

                requestAnimationFrame(update);

                if (!target)
                    return;

                if (dragging) {
                    //totalDegrees = (currentDegrees - startDegrees);
                    totalDegrees = lastDegrees + (currentDegrees - startDegrees);
                    //totalDegrees = currentDegrees;
                    //console.log(totalDegrees);
                    target.style.transform = 'rotate(' + totalDegrees + 'deg)';
                } else {
                    totalDegrees = targetDegrees;
                    target.style.transition = "all 0.2s";
                    target.style.transform = 'rotate(' + totalDegrees + 'deg)';
                    //totalDegrees += lastVelocity / 60; // change the number 20 to change the velocity applied to animation
                }


                

                // User has finished dragging.
                if (dragging)
                    return;

                lastDegrees = totalDegrees % 360;

            }

            //pointer.addEventListener('mousemove', rotatePointer);
            pointer.addEventListener('touchend', onEnd);
            pointer.addEventListener('touchmove', onMove);
            pointer.addEventListener('touchstart', onStart);
        })









        function easeOutCubic(currTime, beginningValue, change, duration) {
            return change * ((currTime = currTime / duration - 1) * currTime * currTime + 1) + beginningValue;
        }

        





        class Cards {
            constructor() {
                this.cards = Array.from(document.querySelectorAll('.card'));

                this.onStart = this.onStart.bind(this);
                this.onMove = this.onMove.bind(this);
                this.onEnd = this.onEnd.bind(this);
                this.update = this.update.bind(this);
                this.targetBCR = null;
                this.target = null;
                this.startX = 0;
                this.startTime = 0;
                this.endTime = 0;
                this.currentX = 0;
                this.screenX = 0;
                this.targetX = 0;
                this.lastVelocity = 0;
                this.draggingCard = false;

                this.addEventListeners();

                requestAnimationFrame(this.update);
            }

            addEventListeners() {
                document.addEventListener('touchstart', this.onStart);
                document.addEventListener('touchmove', this.onMove);
                document.addEventListener('touchend', this.onEnd);

                document.addEventListener('mousedown', this.onStart);
                document.addEventListener('mousemove', this.onMove);
                document.addEventListener('mouseup', this.onEnd);
            }

            onStart(evt) {
                if (this.target)
                    return;

                if (!evt.target.classList.contains('card'))
                    return;

                this.target = evt.target;
                this.targetBCR = this.target.getBoundingClientRect();

                this.startX = evt.pageX || evt.touches[0].pageX;
                this.startTime = Date.now() / 1000;
                this.currentX = this.startX;

                this.draggingCard = true;
                this.target.style.willChange = 'transform';

                evt.preventDefault();
            }

            onMove(evt) {
                if (!this.target)
                    return;

                this.currentX = evt.pageX || evt.touches[0].pageX;
            }

            onEnd(evt) {
                if (!this.target)
                    return;

                this.targetX = 0;
                this.endTime = Date.now() / 1000;
                let screenX = this.currentX - this.startX;
                const threshold = this.targetBCR.width * 0.35;
                if (Math.abs(screenX) > threshold) {
                    this.targetX = (screenX > 0) ?
                        this.targetBCR.width :
                        -this.targetBCR.width;
                }

                this.draggingCard = false;

                // calculate velocity
                this.lastVelocity = (evt.pageX - this.startX) / (this.endTime - this.startTime);
                console.log(this.lastVelocity);
            }

            update() {

                requestAnimationFrame(this.update);

                if (!this.target)
                    return;

                if (this.draggingCard) {
                    this.screenX = this.currentX - this.startX;
                } else {
                    this.screenX += this.lastVelocity / 20; // change the number 20 to change the velocity applied to animation
                }


                const normalizedDragDistance =
                    (Math.abs(this.screenX) / this.targetBCR.width);
                const opacity = 1 - Math.pow(normalizedDragDistance, 3);

                this.target.style.transform = `translateX(${this.screenX}px)`;
                this.target.style.opacity = opacity;

                // User has finished dragging.
                if (this.draggingCard)
                    return;

                const isNearlyAtStart = (Math.abs(this.screenX) < 0.1);
                const isNearlyInvisible = (opacity < 0.01);

                // If the card is nearly gone.
                if (isNearlyInvisible) {

                    // Bail if there's no target or it's not attached to a parent anymore.
                    if (!this.target || !this.target.parentNode)
                        return;

                    this.target.parentNode.removeChild(this.target);

                    const targetIndex = this.cards.indexOf(this.target);
                    this.cards.splice(targetIndex, 1);

                    // Slide all the other cards.
                    this.animateOtherCardsIntoPosition(targetIndex);

                } else if (isNearlyAtStart) {
                    this.resetTarget();
                }
            }

            animateOtherCardsIntoPosition(startIndex) {
                // If removed card was the last one, there is nothing to animate.
                // Remove the target.
                if (startIndex === this.cards.length) {
                    this.resetTarget();
                    return;
                }

                const onAnimationComplete = evt => {
                    const card = evt.target;
                    card.removeEventListener('transitionend', onAnimationComplete);
                    card.style.transition = '';
                    card.style.transform = '';

                    this.resetTarget();
                };

                // Set up all the card animations.
                for (let i = startIndex; i < this.cards.length; i++) {
                    const card = this.cards[i];

                    // Move the card down then slide it up.
                    card.style.transform = `translateY(${this.targetBCR.height + 20}px)`;
                    card.addEventListener('transitionend', onAnimationComplete);
                }

                // Now init them.
                requestAnimationFrame(_ => {
                    for (let i = startIndex; i < this.cards.length; i++) {
                        const card = this.cards[i];

                        // Move the card down then slide it up, with delay according to "distance"
                        card.style.transition = `transform 150ms cubic-bezier(0,0,0.31,1) ${i * 50}ms`;
                        card.style.transform = '';
                    }
                });
            }

            resetTarget() {
                if (!this.target)
                    return;

                this.target.style.willChange = 'initial';
                this.target.style.transform = 'none';
                this.target = null;
            }
        }

        window.addEventListener('load', () => new Cards());
    </script>
</body>
</html>
